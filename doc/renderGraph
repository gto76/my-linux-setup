#!/bin/bash

USAGE=`basename "$0"`" [ASCII GRAPH FILE] [FONT NAME]"
DESCRIPTION="Reads a graph from ascii drawing and creates png file using image magic convert command."

if [[ "$#" -lt 1 || "$1" == "--help" ]]; then
	echo -e "Usage: $USAGE"; echo -e "$DESCRIPTION"; exit
fi

#########         #########         ######### 
DEBUG="false"
# Size factor (how many pixels does one cell take up)
SIZEY=${2:-"60"}
FONT=${3:-"DejaVu-Sans-Mono-Oblique"}
TAB_WIDTH=4
COLOR="true"
#########         #########         #########

#######################
#### SET CONSTANTS ####
#######################

setConstants() {
	# Width of one ascii cell in pixels.
	SIZEX=`echo "scale=1;$SIZEY*2/3" | bc | sed 's/\..*//'`
	# Heigh of a font.
	let FONT_SIZE=("$SIZEY"*3)/4
	# Distance from rectangles edge to the edge of the cell in the pixels.
	let RECTANGLE_OFFSET="$SIZEX"/8
	# An estimate of font-width/font-height.
	FONT_WIDTH_FACTOR="0.6107" 
	# Additional heightening of the text expressed in height of a text
	VERTICAL_LIFT_FACTOR="0.13"
	VERTICAL_LIFT_EXPRESSION="scale=1;$FONT_SIZE*$VERTICAL_LIFT_FACTOR"
	VERTICAL_LIFT=`echo "$VERTICAL_LIFT_EXPRESSION" | bc | sed 's/\..*//'`
	let RECTANGLE_HEIGHT="$SIZEY"-2*"$RECTANGLE_OFFSET"
	# How far from the upper cells will be texts bottom.
	let TEXT_OFFSET_Y=("$RECTANGLE_HEIGHT"-"$FONT_SIZE")/2+"$RECTANGLE_OFFSET"+"$FONT_SIZE"-"$VERTICAL_LIFT"
}

###############################
#### COPY LINES INTO ARRAY ####
###############################

copyLinesIntoArray() {
	SAVE_IFS="$IFS"
	IFS=$'\n'
	i=0
	for a in `expand -t "$TAB_WIDTH" "$1"`; do
		lines["$i"]="$a"
		let i="$i"+1
	done
	IFS="$SAVE_IFS"
}

###############################
#### CALCULATE CANVAS SIZE ####
###############################

calculateCanvasSize() {
	let canvasSizeY=${#lines[@]}*"$SIZEY"
	canvasSizeX=0
	for (( y=0 ; y < ${#lines[@]} ; y++ )); do
		if [[ ${#lines["$y"]} -gt "canvasSizeX" ]]; then
			canvasSizeX=${#lines["$y"]}
		fi
	done
	let canvasSizeX="$canvasSizeX"*"$SIZEX"
}

#######################
#### PROCESS LABEL ####
#######################

setColor() {
	color="rgb(138, 226, 52)" #branch -> lime
	if [[ -n `echo "$1" | grep -i '^origin'` ]]; then
		color="rgb(239, 41, 41)" #remote -> red
	elif [[ -n `echo "$1" | grep -i '^head'` ]]; then
		color="rgb(52, 226, 226)" #HEAD -> aqua
	elif [[ -n `echo "$1" | grep -i '^v[0-9]\|^[0-9]'` ]]; then
		color="rgb(252, 233, 77)" #tag -> yelow
	fi
}

# Reads label until it reaches connector or space
# Draws rectangle and label on it.
processLabel() {
	restOfLine=${lines[$y]:$x}
	echo "restOfLine: $restOfLine\n"
	label=`echo "$restOfLine" | grep -o "^[^ +()|\n\-]*"`
	length=${#label}
	let newX="$x"+"$length"
	let yPlus1="$y"+1
	# RECTANGLE:
	let rectangleX="$x"*"$SIZEX"+"$RECTANGLE_OFFSET"
	let rectangleY="$y"*"$SIZEY"+"$RECTANGLE_OFFSET"
	let rectangleX2="$newX"*"$SIZEX"-"$RECTANGLE_OFFSET"
	let rectangleY2="$yPlus1"*"$SIZEY"-"$RECTANGLE_OFFSET"
	if [[ "$COLOR" == "true" ]]; then
		setColor "$label"
		instructionRectangle="rectangle#fill '$color' rectangle $rectangleX,$rectangleY $rectangleX2,$rectangleY2 fill 'white'\n"
	else
		instructionRectangle="rectangle $rectangleX,$rectangleY $rectangleX2,$rectangleY2\n"
	fi
	# TEXT:
	# position x:
    textWidthExpression="scale=1;$FONT_SIZE*$length*$FONT_WIDTH_FACTOR"
	textWidth=$(echo "$textWidthExpression" | bc | sed 's/\..*//')
	let rectangleWidth="$length"*"$SIZEX"-2*"$RECTANGLE_OFFSET"
	let textOffsetX=("$rectangleWidth"-"$textWidth")/2+"$RECTANGLE_OFFSET"
	let textX="$x"*"$SIZEX"+"$textOffsetX"
	# position y;
	let textY="$y"*"$SIZEY"+"$TEXT_OFFSET_Y"
	instructionText="text $textX,$textY '$label'\n"

	instructions="$instructions""$instructionRectangle""$instructionText"
	x="$newX"
}

######################
#### PROCESS NODE ####
######################

# Draws a circle and nodes label on it.
processNode() {
	let xPlus1="$x"+1
	let yPlus1="$y"+1
	label=${lines[$y]:$xPlus1:1}

	# Circle:
	let circleX="$xPlus1"*"$SIZEX"+"$SIZEX"/2
	let circleY="$y"*"$SIZEY"+"$SIZEY"/2
	let circleY2="$y"*"$SIZEY"
	instructionCircle="m#circle $circleX,$circleY $circleX,$circleY2\n"
	# Text:
	#let labelX="$xPlus1"*"$SIZEX"
	length=1
    textWidthExpression="scale=1;$FONT_SIZE*$length*$FONT_WIDTH_FACTOR"
	textWidth=$(echo "$textWidthExpression" | bc | sed 's/\..*//')
	let rectangleWidth="$length"*"$SIZEX"-2*"$RECTANGLE_OFFSET"
	let textOffsetX=("$rectangleWidth"-"$textWidth")/2+"$RECTANGLE_OFFSET"
	let textX="$xPlus1"*"$SIZEX"+"$textOffsetX"
	#let labelY="$yPlus1"*"$SIZEY"-"$SIZEY"/4
	let textY="$y"*"$SIZEY"+"$TEXT_OFFSET_Y"
	instructionText="text $textX,$textY '$label'\n"

	instructions="$instructions""$instructionCircle""$instructionText"
	let x="$x"+2
}

######################
#### PROCESS EDGE ####
######################

# Investigates where does edge lead and draws a line between the ends.
processEdge() {
	local char=${lines[$y]:$x:1}
	if [[ "$char" == '|' ]]; then
		findEdgesEndpoints 0 -1 0 1 "$char"
	elif [[ "$char" == '-' ]]; then
		findEdgesEndpoints -1 0 1 0 "$char"
	elif [[ "$char" == '/' ]]; then
		findEdgesEndpoints 1 -1 -1 1 "$char"
	elif [[ "$char" == '\' ]]; then
		findEdgesEndpoints -1 -1 1 1 "$char"
	fi

	instruction="line $endpoint1 $endpoint2"
	instructions="$instructions""$instruction""\n"
}

# Finds the two endpoints of the edge
# Arguments: 
# $1 - delta x of first direction, $2 - delta y of first direction,
# $3 - delta x of oposite direction, $4 - delta y of oposite direction
# $5 - the character reptesenting the edge
findEdgesEndpoints() {
	connectToX="$x"; connectToY="$y"
	findEdgesEndpoint "$1" "$2" "$5"
	let connectToX="$connectToX"*"$SIZEX"+"$SIZEX"/2
	let connectToY="$connectToY"*"$SIZEY"+"$SIZEY"/2
	endpoint1="$connectToX,$connectToY"
	connectToX="$x"; connectToY="$y"
	findEdgesEndpoint "$3" "$4" "$5"
	let connectToX="$connectToX"*"$SIZEX"+"$SIZEX"/2
	let connectToY="$connectToY"*"$SIZEY"+"$SIZEY"/2
	endpoint2="$connectToX,$connectToY"
}

# Finds the endpoint in the specified direction
# $1 - delta x of direction, $2 - delta y of direction,
# $3 - the character reptesenting the edge
findEdgesEndpoint() {
	let newX="$connectToX"+"$1"
	let newY="$connectToY"+"$2"
	local char=${lines[$newY]:$newX:1}
	if [[ -z "$char" || "$char" == ' ' ]]; then
		return
	# If this field has the same edge character, continue to next one
	elif [[ "$char" == "$3" ]]; then
		connectToX="$newX"
		connectToY="$newY"
		findEdgesEndpoint "$@"	
	elif [[ "$char" == '(' ]]; then
		let connectToX="newX"+1
		let connectToY="newY"
		return
	elif [[ "$char" == ')' ]]; then
		let connectToX="newX"-1
		let connectToY="newY"
		return
	else
		connectToX="$newX"
		connectToY="$newY"
		return
	fi
}

###########################
#### SORT INSTRUCTIONS ####
###########################

# Sort instructions so that edges get drawn first, then circles
# and rectangles and lastly the labels.
sortInstructions() {
	orderedInstructions=`echo -e "$instructions" | sort -u | sed 's/^.*#//'`
	if [[ "$DEBUG" == "true" ]]; then
		echo -e "\nINSTRUCTIONS:\n$orderedInstructions"
	fi
	drawingInstructions=`echo -e "$orderedInstructions" | grep -v '^text '`
	textInstructions=`echo -e "$orderedInstructions" | grep '^text '`
}

####################
#### CREATE PNG ####
####################

createPng() {
	echo -e "push graphic-context\n" > tmp.mvg
	echo -e "viewbox 0 0 $canvasSizeX $canvasSizeY" >> tmp.mvg
	echo -e "fill 'white'" >> tmp.mvg
	echo -e "stroke 'black'" >> tmp.mvg
	echo -e "stroke-antialias 1" >> tmp.mvg
	#echo -e "stroke-width 2" >> tmp.mvg
	echo -e "$drawingInstructions\n" >> tmp.mvg
	echo -e "push graphic-context" >> tmp.mvg
	echo -e "fill 'black'" >> tmp.mvg
	echo -e "font-size $FONT_SIZE" >> tmp.mvg
	echo -e "font '$FONT'" >> tmp.mvg
	echo -e "text-antialias 1" >> tmp.mvg
	echo -e "stroke-opacity 0" >> tmp.mvg
	echo -e "$textInstructions\n" >> tmp.mvg
	echo -e "pop graphic-context" >> tmp.mvg
	echo -e "pop graphic-context" >> tmp.mvg
	convert tmp.mvg tmp.png
}

##############
#### MAIN ####
##############

main() {
	setConstants
	copyLinesIntoArray "$1"
	calculateCanvasSize

	# Drawing instructions for the imagemagic
	instructions=""

	if [[ "$DEBUG" == "true" ]]; then
		echo "INPUT FILE:"
		cat "$1"
		echo -e "\nPARSING:"
	fi

	# Parse.
	for (( y=0 ; y < ${#lines[@]} ; y++ )); do
		if [[ "$DEBUG" == "true" ]]; then
			echo -e "\nLine no $y: \"${lines[$y]}\""
		fi
		for (( x=0 ; x < ${#lines[y]} ; x++ )); do
			# getChar "$x" "$y":
			char=${lines[$y]:$x:1}
			if [[ "$DEBUG" == "true" ]]; then
				echo -en "\n$x" "$y" \""$char"\"' '
			fi	
			if [[ '-|/\\+() ' != *"$char"* ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n label 
				fi
				processLabel
			fi
			if [[ "$char" == '(' ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n node 
				fi
				processNode 
			fi
			if [[ '-|/\' == *"$char"* ]]; then
				if [[ "$DEBUG" == "true" ]]; then
					echo -n edge
				fi
				processEdge
			fi
		done
		if [[ "$DEBUG" == "true" ]]; then
			echo
		fi
	done

	sortInstructions
	createPng
}

main "$@"
