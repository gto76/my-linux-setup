 _   _                __   __            _  __                    
| \ | | _____      __ \ \ / /__  _   _  | |/ /_ __   _____      __
|  \| |/ _ \ \ /\ / /  \ V / _ \| | | | | ' /| '_ \ / _ \ \ /\ / /
| |\  | (_) \ V  V /    | | (_) | |_| | | . \| | | | (_) \ V  V / 
|_| \_|\___/ \_/\_/     |_|\___/ \__,_| |_|\_\_| |_|\___/ \_/\_/  

...............
...............
...... C ......
...............
...............

STRLEN VS SIZEOF
A: const char *str = "foo";
is the same as
const char *str = {'f', 'o', 'o', 0};

strlen ("hello, world") ⇒ 12 // (one less than the amount of space it takes)

char string[32] = "hello, world";
sizeof (string) ⇒ 32
strlen (string) ⇒ 12

But beware, this will not work unless string is the character array itself, not a pointer to it. For example:

char string[32] = "hello, world";
char *ptr = string;
sizeof (string) ⇒ 32
sizeof (ptr) ⇒ 4  /* (on a machine with 4 byte pointers) */

This is an easy mistake to make when you are working with functions that take string arguments; those arguments are always pointers, not arrays.

Q: I declared a 2-dimensional array like this:
char *array[][3] = {
    {"a", "b", "c"},
    {"d", "e", "f"},
    {"u", "v", "w"},
    {"x", "y", "z"}};
How do I find out the first dimension?
A: sizeof array / sizeof array[0]

Q: Are all char arrays automatically null-terminated?
A: Only string literals get null-terminated, and that means that char x[]="asdf" is an array of 5 elements.

Q: How to automaticaly initialize array?
A: int arr[10] = {0} ⇒ This will initialized the first value to zero, and all subsequent values to 0. If you put a 1 between the curly braces, it would initialize the first value to 1, and all subsequent values to 0. 

Q: In C, I can do like this:
char s[]="hello"; or
char *s ="hello";
So I wonder what is the difference?

A:The difference here is that
char *s = "Hello world";
will place Hello world in the read-only parts of the memory and making s a pointer to that, making any writing operation on this memory illegal. While doing:

char s[] = "Hello world";
puts the literal string in read-only memory and copies the string to newly allocated memory on the stack. Thus making
s[0] = 'J';
legal. 

POINTER ARITHMETIC
------------------
When arithmetic is performed with a pointer and an integer quantity, the integer is always scaled to the size of type the pointer is pointing to.

Two forms are allowed:
pointer +/- integer and
pointer - pointer (only if they point to the same array)

============
ARRAYS
============

One-dimensional Arrays

Array Names
-----------
IN C, when name of an array is used in almost any expression, the value of the name is a pointer constant that is the address of the first element of the array. 
Do not conclude from this that arrays and pointers are the same. An array has quite different characteristics than a pointer, for example, an array has a certain number of elements, while a pointer is a scalar. The compiler uses the array name to keep track of these properties. It is only what the array name is used in an expression that the compiler generates the pointer constant.
There are only two places where this pointer substitution does not occur - when an array name is an operand of either sizeof or the unary operator &. sizeof returns the size of the entire array, not the size of pointer to the array. Taking the address of an array name gives a pointer to the first element in the array, not a pointer to some substituted pointer constant value.

Subscripts
----------
array[subscript] gets translated into (is same as)
*( array + (subscript) )

The fact that subscripts can be applied to arbitrary pointer, not just array names, makes subscript checking difficult task.

Arrays and Pointers
-------------------
Pointers and arrays are not equivalent.
Declaring an array sets aside space in memory for the indicated number of elements, and than creates array name whose value is a constant that points to the beginning of this space. Declaring a pointer variable reserves space for the pointer itself but that is all. 

Array Names as Function Arguments
----------------------------------
What happens when an array name is passed as an argument to a function? You now know that the value of an array name is a pointer to the first element of the array, so it makes sense that a copy of this pointer value is passed to the function. A subscript used in the function will perform indirection on this pointer, and it is through this indirection that the function can success or modify the elements of the calling program's array.
There are two other points about this function that are worth mentioning (or reiterating). First, the parameter is declared as a pointer to const characters. Why is this declaration important for a function that is not going to modify the characters in the first place? There are at least three reasons. First, it is good documentation. Someone wishing to use this function can see from the prototype that the data will not be changed, without reading the code (which might not be available). Second, the compiler will be able to catch any programming error that causes accidental modification. Lastly, the declaration allows const arguments to be passed to the function.

Declaring Array Parameters
--------------------------
The following function prototypes are equivalent:
int strlen(char *string);
int strlen(char string[]);
This two declarations are equivalent in this context only! Everywhere else they are quite different, as discussed earlier But for array parameters, you may use either declaration.
You can use either declaration,but which is "more correct?" The pointer.
The argument is really a pointer, not the array. Also the expression sizeof string will produce the size of pointer to a character not the size of array.
On the other hand, this implementation makes it impossible for the function to determine the size of the array. If the array size is needed in the function, it must be passed as an explicit argument.

Initialization
--------------
If static array was not initialized, the initial values will be zero.

Character Array Initialization
-----------------------------
char message1[] = "Hello";
char *message2 = "Hello";
The initializers look alike, but they have different meanings. The first initializes the elements of  character array, but the second is a true string literal. The pointer variable is initialized to point to wherever the literal is stored.

Pointers to Arrays
------------------
int (*p)[10];
Adding initialization to the declaration gives us:
int (*p)[10] = matrix;
which makes p point to the first row of matrix.
What should you do if you want a pointer that will go through the matrix integer by integer rather than row by row?
int *pi = &matrix[0][0];
int *pi = matrix[0];
Both point to the first integer in the matrix. 
If you intend to perform any arithmetic with the pointer avoid this kind of declaration:
int (*p)[] = matrix;
p is still a pointer to an array of integers, but the array size is missing. Integers involved in pointer arithmetic with this variable will be scaled by the size of an empty array (that is, multiplied by zero).

Multidimensional Arrays as Function Arguments
---------------------------------------------
The value of a multidimensional array name is a pointer to its first element, which will be a pointer to an array. Arithmetic with this pointer will be scaled by the size of the array.
x
Either of the following forms could be used:
void func2 (int (*mat)[10]);
void func2 (int mat[][10]);

The key here is that the compiler must know the sizes of the second and subsequent dimensions in order to evaluate subscripts, thus the prototype must declare these dimensions.
Specifically, it is incorrect to prototype func2 like this:
void func2 (int **mat);
This example declares mat to be a pointer to a pointer to an integer, which is not at all the same ting as a pointer to an array of ten integers.

Automatic Array Sizing
----------------------
With multidimensional arrays, only the first dimension of the array can be implied by the initializer list. The remaining ones are needed so that the compiler can determine the size of each subordinate dimension. For example:
int two_dim[][5] = {
	{ 00, 01, 02 },
	{ 10, 11},
	{ 20, 21, 22, 23 }
};

Arrays of Pointers
------------------
int *api[10];

char const *keyword[] = {
	"do",
	"for",
	"if",
	"register",
	NULL
};

Print Contents:
int printPointerArray(char const *keyword[]) {
	char const **kwp;
	for (kwp = keyword_table; *kwp != NULL; kwp++) {
		printf("%s", *kwp);
	}
}


...........................
........ L I N U X ........
....... S Y S T E M .......
.. P R O G R A M M I N G ..
...........................
LINUX ABSTRACTIONS:
1.FILE
2.PROCESS
triplet of the Linux kernel (the heart of
the operating system), the GNU C library (glibc), and the GNU C Compiler

ABI (application binary interface):
Thus, each machine architecture has its
own ABI on Linux. In fact, we tend to call a particular ABI by its machine name, such
as Alpha, or x86-64. Thus, the ABI is a function of both the operating system (say, Linux)
and the architecture (say, x86-64)

SPECIAL FILES:
Linux supports four: block device
files (disk), character device files (keyboard), named pipes, and Unix domain sockets.

INTERPROCESS COMMUNICATION:
mechanisms supported by Linux include pipes, named pipes, semaphores, message
queues, shared memory, and futexes.

Modern operating systems provide two fundamental virtualized abstractions to user-space: virtual memory and a virtualized processor.

MEMORY:
Unlike malloc(), which makes no such guarantees about the contents of allocated memory, calloc() zeros all bytes in the returned chunk of memory.

/* like malloc(), but zeros memory and terminates on failure */
void * xmalloc0 (size_t size) {
	void *p;
	p = calloc (1, size);
	if (!p) {
		perror ("xmalloc0");
		exit (EXIT_FAILURE);
	}
	return p;
}

APPROACH  | PROS						    |CONS
----------+---------------------------------+----------------------------------------------
malloc()  |	Easy, simple, common. 			|Returned memory not necessarily zeroed.
calloc()  |	Makes allocating arrays simple, |Convoluted interface if not allocating arrays.
          |	zeros returned memory. 			|
realloc() |	Resizes existing allocations. 	|Useful only for resizing existing allocations.

void free (void *ptr);
A call to free() frees the memory at ptr. The parameter ptr must have been previously
returned by malloc(), calloc(), or realloc(). That is, you cannot use free() to free
partial chunks of memory—say, half of a chunk of memory—by passing in a pointer
halfway into an allocated block

.............
.............
.. M A K E ..
.............
.............
--------------
SPECIAL MACROS
--------------
All special macros begin with a dollar sign and do not need to be surrounded by parenthesis:

* $@ - name of the target
		client: client.c
			$(CC) client.c -o $@

* $? - lisf of dependents more recent than the target
		client: client.c
			$(CC) $? -o $@

* $^ - all dependencies, withoth dupicates
		viewsource: client.c server.c
			less $^

* $+ - all dependencies
		viewsource: client.c server.c
			less $+

* $< - only first dependency

----------------------------
WILDCARD MATCHING IN TARGETS
----------------------------
* % - wildcard in target
* $* - if you need the matched text in in the command

	%:
		gcc -o $* $*.c

>so for example 'make test_executable' will expand to:

	gcc -o test_executable test_executable.c	

-----------------------
FUNCTIONS FOR FILENAMES
-----------------------
* $(dir names...) - extract the directory part of each filename in names

* $(notdir names...) - extract all but the directory path

* $(suffix names...) - extract the suffix of each file name

* $(basename names...) - extract all but the suffix

* $(addsuffix suffix,names...) - adds suffix to all filenames

* $(addprefix prefix,names...) - glues pefix part (usualy path) in front of the names

* $(join list1,list2) - concatenates the two arguments word by word: '$(join a b,.c .o)' produces 'a.c b.o'

* $(wildcard pattern) - using shell file name patterns it returns list of matching files

* $(realpath names...) - return the canonical absolute name, meaning without no . or .. components nor any symlinks

* $(abspath names...) - same as realpath, but does not reslolve symlinks, and does not require the file names to refer to an existing file or directory

------------------------------
CREATING A LIST OF DIRECTORIES
------------------------------

DIRS := ${shell find ${ROOT_DIRECTORY} -type d -print}

--------------------
USING CD IN COMMANDS
--------------------
>There must be no new line characte between the lines, because otherwise the cd command will get executed in its own subshell. Consequentlly the semi-colon also needs to be added after every statement.

	all:
		cd some_dir; \
		gcc -Wall -o myTest myTest.c

.......................
.......................
.. E F F E C T I V E ..
....... J A V A .......
.......................
.......................
--------------------------------
CREATING AND DESTROYING OBJECTS:
--------------------------------
1. Consider static factory methods instead of Constructors:
	+ They have names.
	+ They are not required to create a new object each time they're invoked.
	+ They can return an object of any subtype of their return type.
	- Classes without public or protected constructors cannot be subclassed.
	- They are not readily distinguishable from other static methods.
2. Consider a builder when faced with many constructor parameters.
3. Enforce the singleton property with a private constructor or an enum type. 
	Single-element enum is the best way to implement a singleton.
4. Enforce noninstantiability with a private constructor.
7. Avoid finalizers. 
	Never do anything time-critical in a finalizer. 
	Provide an explicit termination method.

------------------------------
METHODS COMMON TO ALL OBJECTS:
------------------------------
8. Obey the general contract when overriding equals.
	1. Use the == operator to check if the argument is a reference to this object.
	2. Use the instanceof operator to check if the argument has the correct type.
	3. Cast the argument to correct type.
	4. For each "significant" field in the class, check if that field of the argument matches.
	5. Ask yourself three questions: Is it symmetric? Is it transitive? Is it consistent?
9. Always override hashcode when you override equals. 
	Equal objects must have equal hash codes.

-----------------------
CLASSES AND INTERFACES: 
-----------------------
13. Minimize the accessibility of classes and members. 
	It is wrong for a class to have a public static final array field, or an accessor that returns such a field. Use UnmodifiableList.
15. Minimize mutability. 
	Classes should be immutable unless there's a very good reason to make them mutable. 
	Make every field final unless there is a compelling reason to make it nonfinal.
16. Favor composition over inheritance. 
	Inheritance violates encapsulation.
17. Design and document for inheritance or else prohibit it. 
	The class must document its self-use of overridable methods. 
	Constructors must not involve overridable methods. 
	Neither clone nor readObject may invoke an overridable method directly of indirectly.
18. Prefer interfaces to abstract classes. 
	You can combine the virtues of interfaces and abstract classes by providing an abstract skeletal implementation class to go  with each nontrivial interface that you export.

---------
GENERICS:
---------
Parametrized type		| List<String>
Actual type parameter	| String
Generic type			| List<E>	
Formal type parameter	| E
Unbounded wildcard type	| List<?>
Raw type				| List
Bounded type parameter	| <E extends Number>
Recursive type bound	| <T extends Comparable<T>>
Bounded wildcard type	| List<? extends Number>
Generic Method			| static <E> List<E> asList(E[] a)
Type token				| Strung.class

If a type parameter appears only once in a method declaration, replace it with a wildcard.

----------------------
ENUMS AND ANNOTATIONS:
----------------------
32. Use EnumSet instead of bit fields.
33. Use EnumMap instead of ordinal indexing.
34. Emulate extensible enums with interfaces. 
	Enums can implement original enums interface and be used in place of original enum.

--------
METHODS:
--------
38. Check parameters for validity.
39. Make defensive copies when needed.
	Defensive copies are made before checking the validity of the parameters, and the validity check is performed on the copies.
43. Return empty arrays or collections, not nulls.
44. Write doc comments for all exposed API elements. 
	Use {a code} for code in doc comments

--------------------
GENERAL PROGRAMMING:
--------------------
49. Prefer primitive types to boxed primitives. 
	Applying the == operator to boxed primitives is almost always wrong. When you mix primitives and boxed primitives in a single operation, the boxed primitive is auto-unboxed.

-----------
EXCEPTIONS:
-----------
58. Use checked exceptions for recoverable conditions and runtime exceptions for programing errors. 
	All of the unchecked throwables you implement should subclass RuntimeException.
60. Favor the use of standard exceptions: IllegalArgumentExceptin, IllegalStateException, NullPointerException, IndexOutOfBoundsException, ConcurentModificationException, UnsupportedOperationException
61. Throw exceptions appropriate to the abstraction. 
	Higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction. (Exception translation)
62. Document all exceptions thrown by each method.
63. Include failure-capture information in detail messages. 
	Should contain all parameters and fields that contributed to the exception.
64. Strive for failure atomicity. 
	A failed method invocation should leave the object in the state that it was in prior to invocation.

------------
CONCURRENCY:
------------
66. Synchronize access to shared mutable date. 
	Synchronization has no effect unless both read and write operations are synchronized. 
	Confine mutable data to a single thread.
67. Avoid excessive synchronization. 
	As a rule, you should do as little work as possible inside synchronized regions.
68. Prefer executors and tasks to threads.
69. Prefer concurrency utilities to wait and notify. 
	Use ConcurentHashMap in preference to synchronyzedMap or HashTable. 
	For interval timing, always use System.nanoTime in preference to System.currentTimeMillis.
70. Document thread safety. 
	To enable safe concurrent use, a class must clearly document what level of thread safety it supports. 
	Levels of thread safety:
		1. Immutable
		2. Unconditionally thread-safe -> No need for external synchronization.
		3. Conditionally thread-safe -> Some methods require external synchronization.
		4. Non thread-safe -> All methods require external synchronization.
		5. Thread hostile.
71. Use lazy initialization judiciously.
72. Don't depend on thread scheduler. 
	Threads should not run if they are not doing useful work. 
	Thread priorities are among the least portable features of the Java platform.
73. Avoid thread groups. 
	Thread groups are obsolete.

--------------
SERIALIZATION:
--------------
74. Implement Serializable judiciously.
75. Consider using custom serialized form. 
	Default serialized form is likely to be appropriate if an object's physical representation is identical to its logical content. 
	Even if you decide that the default serialized form is appropriate, you often must provide readObject method to ensure invariants and security.
	Before deciding to make a field non-transient, convince yourself that its value is part of the logical state of the object.
	You must impose any synchronization on object serialization that you would impose on any other method that reads the entire state of the object.
	Declare UID.
76. Write read Object methods defensively. Defensive copy.
77. For instance control, prefer enum types to readResolve.
78. Consider serialization proxies instead of serialized instance.

--------------------------------
NEW COLLECTION INTERFACES IN 6.0:
--------------------------------
Deque -> Double ended queue. (ArrayDeque, LinkedList)
NavigableSet -> SortedSet extended. (TreeSet)
NavigableMap -> SortedMap extended. (TreeMap)

.....................
.....................
...... J A V A ......
..... S W I N G .....
.....................
.....................
TO CENTER A LABEL IN A CONTAINER (HORIZONTALLY AND VERTICALLY):

JPanel innerPanel = new JPanel();
JLabel label = new JLabel();
innerPanel.add(label);

JPanel outerPanel = new JPanel(new GridBagLayout());
outerPanel.add(innerPanel);

containter.add(outerPanel);

.........................
.. D I S T R I B U T E ..
........ J A V A ........
........ A P P S ........
.........................
DISTRIBUTE JAVA APPS:
1. Just use jar.
2. Use launch4j and an installer like NSIS.
3. Use Webstart.
4. Use a native-code compiler like Excelsior JET and distribute as a executable, or wrap it up in an installer.
-----
Java desktop app:
On Windows this means .exe, start menu links, control panel integration and specific task manager process for example with minimal overhead start time for a small app (still waiting for update 10 here...) and a shiny own icon in the taskbar when they launch it, not a Java icon.
----
JNLP / webstart / RCP (eclipse) / InstallBuilder (for adding jre to install)
If you're building an application atop SWT/JFace/RCP rather than Swing, you can create and run a product build in the Eclipse IDE, which results in an executable, making something like exe4j unnecessary
----
Convert Jar file to EXE executable:
JSmooth .exe wrapper (2007)
JarToExe 1.8
Executor
Advanced Installer
LaunchAnywhere
JexePack (Class to EXE)
Launch4j

...............
...............
.. M A V E N ..
...............
...............
mvn / maven2 / m2e

(bin - sh scripts (run.sh))
src/main/java/com... - source
src/test/java/com... - test source (junits)
src/test/resources/images/ - test images
(test-data/)
target/classes - compiled classes
pom.xml - build commands file

"from manual:"
----------------------------------------------------
src/main/java		Application/Library sources
src/main/resources 	Application/Library resources
src/main/filters 	Resource filter files
src/main/assembly 	Assembly descriptors
src/main/config 	Configuration files
src/main/scripts 	Application/Library scripts
src/main/webapp 	Web application sources
src/test/java		Test sources
src/test/resources 	Test resources
src/test/filters 	Test resource filter files
src/site			Site
LICENSE.txt			Project's license
NOTICE.txt			Notices and attributions required by libraries that the project depends on
README.txt			Project's readme

Eclipse:

Convert to maven project:
right click on project > configure > convert to maven project

Add dependency:
right click on project > maven > add dependency

Reseting project (may help in times of discontent):
F5 - refresh
Project > clean
maven > update project
maven > disable dependency management, then maven > enable dependency management
close the project then reopen it
if you are behind proxy, then configure proxy settings

.....................
.....................
....... S B T .......
.....................
.....................
Installing Scala
----------------
export SCALA_VERSION=2.11.1
wget http://downloads.typesafe.com/scala/$SCALA_VERSION/scala-$SCALA_VERSION.tgz
tar xvzf scala-$SCALA_VERSION.tgz
sudo sh -c 'echo "export SCALA_HOME=\"$PWD/scala-$SCALA_VERSION\"" >> /etc/profile'
sudo sh -c 'echo "export PATH=\"\$PATH:\$SCALA_HOME/bin\"" >> /etc/profile'

Installing sbt
--------------
export SBT_VERSION=0.13.5
wget http://dl.bintray.com/sbt/debian/sbt-$SBT_VERSION.deb
sudo dpkg -i sbt-$SBT_VERSION.deb

To Run Project
--------------
1. In project root create file "build.sbt" containing: 
```
name := "<project name>"

version := "0.9.0"

scalaVersion := "2.11.1"
```
2. Run: "sbt run"

To Build fat jar (executable with java -jar, and containing all dependencies)
-----------------
1. Create file "project/assembly.sbt" containing:
```
addSbtPlugin("com.eed3si9n" % "sbt-assembly" % "0.11.2")
```
2. In project root create file "assembly.sbt" containing:
```
import AssemblyKeys._ // put this at the top of the file

assemblySettings

// your assembly settings here
```
3. Run: "sbt assembly"
4. Run: "java -jar target/scala-x.x.x/<jar name>.jar"

.................
.................
.... W E K A ....
.................
.................
----------------
FORMATING INPUT:
----------------
1. DECLARE ATTRIBUTES:
	Numeric:
		Attribute Attribute1 = new Attribute("firstNumeric");
	Nominal:
		FastVector fvNominalVal = new FastVector(3);
		fvNominalVal.addElement("blue");
		fvNominalVal.addElement("gray");
		fvNominalVal.addElement("black");
		Attribute Attribute2 = new Attribute("aNominal", fvNominalVal);
		
2. PUT THEM IN FAST VECTOR:
	FastVector fvWekaAttributes = new FastVector(2);
		 fvWekaAttributes.addElement(Attribute1);    
		 fvWekaAttributes.addElement(Attribute2);

3. CREATE INSTANCES CONTAINER:
	Instances instances = new Instances("entries", fvWekaAttributes, 10); 
	
4. FILL IT WITH INSTANCES
	Instance inst = new Instance(2);
	inst.setValue((Attribute)fvWekaAttributes.elementAt(0), 0.2);
	inst.setValue((Attribute)fvWekaAttributes.elementAt(1), 0.8);

	inst.setDataset(instances);
	instances.add(inst);


SHEMA:
1. Attribute (attribute declarations) -> FastVector (attribute container) -> Istances constructor
2. Double, Attribute -> Instance (instances) -> Istances

.................
.. C O D E R S ..
...... A T ......
.... W O R K ....
.................

JAMIE ZAWINSKI - NETSCAPE
- If you don't understand how something works, ask someone who does. -> communication

BRAD FITZPATRICK - YOUNG GUY
- Google app engine -> basic of today
- Sideprojects -> hiring
- Strace -> favorite tool
- Higher order perl -> book
- Python -> language
- Write to maintainer: "I want to add feature X. I was thinking something like the attached patch", which is totally wrong but say, "but I think It's totally wrong.I'm thinking the right way might be to do X." which is some more complex way.

DOUGLAS CROCKFORD - JSON, JAVASCRIPT: THE GOOD PARTS, KILLED JS4
- Regular code readings in team -> communication
- Art of computer programming -> book
- Being literate -> hiring
- Javascript -> new lego paradigm of programming (now we're in object era)
- Bring your piece of code and walk me trough. I'm looking for how effectively can you communicate. -> hiring

BRENDAN EICH - JAVASCRIPT, NETSCAPE, FIREFOX, WAS PUSHING JS4
- Ocaml intern -> hiring
- Let people talk about their own project -> hiring

JASHUA BLOCH - JAVA5, EFFECTIVE JAVA, JAVA PUZZLERS
- Elements of style -> book
- Java concurrency in practice -> book
- Write the code that uses the api before you write the code that implements it. In fact, write it even before you flash out the spec.
- Use asserts -> information is too valuable to lose.

JOE ARMSTRONG - ERLANG
- Writing Erlang graphics library by bypassing X -> turned out to be easy
- "I've got to choose between A and B", and you describe A and B  to them and then halfway trough that you go, "Yeah B. Thank you, thank you very much." -> explaining to coworkers
- What are the inputs to your problem? What are the outputs to your problem? What is the functional relationship between the two? -> guru answer
- If you want to understand c, write a c compiler.
- Documentation states the problem, code gives the answer.
- Also doesn't use logic puzzles for hiring. 

SIMON PEYTON JONES - HASKELL
- "Just start something, no matter how humble", write a paper about it. -> advice for research students
- Programming pearls -> book
- Purely functional data structures -> book

PETER NORVIG - GOOGLE, NASA, AI PROFESSOR
- Problem when new guys don't check in their experimental branch for weeks.

GUY STEELE - COMMON LISP, SCHEME
- If I could go back and change one thing, I might try to interest some early preliterate people in not using their thumbs when they count.

DAN INGALLS - SMALLTALK
- Be clear about what you're trying to do. -> Being a good technical leader

L PETER DEUTSCH - GHOSTSCRIPT
- "Fast, cheap, good - pick any two." -> old saying in the business
- Things that are getting reused this days are either very large (Mozilla, Apache) or very small (icons, web page designs)
- Every programming language in substantial use today has the concept of pointer. This holds languages back. Problem is the lack of overview. All the connections (references) are made locally inside classes.
- Language systems stand on a tripod: Language, Libraries and Tools.

KEN THOMPSON - UNIX
- I only write down data structures. -> design
- It's just enthusiasm. -> identifying good programmers
- I love yacc, lex is horrible. I write my lexers by hand.
- Computers are played out.

FRAN ALLEN - IBM
- Trying to find out what they are excited about. -> hiring
- Motivation for the design of C was three problems they couldn't solve in the higher level languages: Interrupt handling, Scheduling resources (Taking over machine and scheduling a process that was in the queue) and Memory allocation.
- We in the field have to make it more appealing. We have to give the field an identity that expands it further than the identity it seems to have now - a much more human identity.
- C is bad because it makes impossible to write highly optimizing compilers.

BERNIE COSELL - ARPANET
- Programs ought to make sense and there are very, very few inherently hard problems. -> two convictions he had from the start of his career and showed to be true
- I could write some very complicated code, but it was always in an encapsulated place.
- I'm a big fan of call-once subroutines, where the only function of the subroutine is to abstract some little part of a parent subroutine.
- If the open brace is too far from close brace, then often it's doing too much.
- C: security hazard

DONALD KNUTH - ART OF COMPUTER PROGRAMMING, TEX
- I couldn't teach classes full-time and write software full-time. I could teach classes full-time and write a book full-time.
- One of the most important revolutions in programming languages was the use of pointers in the C language. When X is a pointer and you say x+1, that doesn't mean one more byte, but one more node after X.


.................
.................
..... G I T .....
.................
.................
[Notes from "Git for ages 4 and up" video]
===========================================================================


    ( )            ADD - writes files to the repo. (Into the staging area.)
     |  
    ---
  

 HEAD *master      COMMIT - creates commit object for added files, which 
    \ /                     has an id, and then puts labels on it [HEAD,  
    (A)                     master] (or moves them from previous commit). 
     |                      (Prints branch label that it's advancing and 
    ---                     objects hash)

    
 HEAD *master      BRANCH <label> - stucks a new label on HEAD (withouth 
    \ /                             parameter it prints local branches). 
    (A)-label                       (With -r will print remote branches/ 
     |                              all the references that you have.)
    ---    


 HEAD  master      CHECKOUT <label> - switches which branch it's going to
    \ /                               advance at commit (from master to
    (A)-*label                        label). (If the labels were pointing
     |                                to different commits it would also
    ---                               get the files)


                   MERGE <label> - merge contents of <label> branch into 
                                   HEAD. Also second <label> parameter 
                                   possible -> will merge into it instead
                                   of current branch. There are two
                                   strategys in which git will merge two
                                   branches:
                                   
					 label         FAST FORWARD - if the <label> is  
    label         HEAD | *master   reachable from HEAD and it is located
      |              \ | /         above it.
HEAD (B) *master      (B)
    \ | /      ___\    |
     (A)          /   (A)
      |                | 
     ---              ---
                                   
                       HEAD        RECURSIVE STRATEGY - merges contents and
                        |          creates new commit that has two parents
label HEAD      label  (D)-master  (it can have any number of parents). 
    \   |           \ / |          Moves currnet branch and HEAD labels to
    (B)(C)-*master  (B)(C)         it (<label> stays behind).
     | /       ___\  | / 
    (A)           / (A)
	 |               |      
    ---             ---    
                                   
  
                   RESET -hard HEAD^ - moves current label to commit HEAD-1,
                                       and also does checkout (--hard)


                   LOG - --graph --decorate --all - shows nice history with
                                                  graph


DETACHED HEAD STATE:


                   TAG v1.0 <A> -> CHECKOUT v1.0 - If no branch label is
                   on this commit you get message: "You are in detached
                   head state", meaning that if you want to keep your
                   commits, you need to create a new branch.


TO MERGE NEW FEATURE INTO MASTER:
                   

 label HEAD           	1. - Starting position:
    \   |          
    (B)(C)-*master 
     | /        
    (A)            
     |             
    ---            
                   

 *label HEAD			2. - Checkout label:
     \ /            
     (B)(C)-master  
      | /        
     (A)            
      |             
     ---            


   *label HEAD    		3. - Merge master (recursive), test:
       \ /         
       (D)         
      / |          
    (B)(C)-master  
     | /        
    (A)            
     |             
    ---            


   label HEAD			4. - Checkout master, merge label (fast forward):
       \ /
       (D)-*master
      / |        
    (B)(C)
     | / 
    (A)
     |      
    ---    


WORKING WITH REMOTE REPOSITORIES:


                   CLONE <url or path of origin> <optional different name>
                         - Makes a copy of remote repository. State of our 
                         repo after clone:

    +--------------------+----+- TRACKING BRANCHES - they mean: last time I
    v ORIGIN/LABEL <-----+    |  talked with origin, thats where its label
ORIGIN/HEAD | ORIGIN/MASTER <-+  was.
           \|/ 
     HEAD--(D)--*MASTER <------- Also it did not pull over LABEL branch,
          / |                    because it pulls over only the default
        (B)(C)                   branch, which is master (note that origin
         | /                     and master are just names, they have no 
        (A)                      segnificance).
         |      
        ---    

                   CLONE --bare <url or path of origin> <optional different
                         name> - Make a copy of repo, containing only
                                 contents of .git directory (there is no
                                 checkout.

                   REMOTE -v - List remotes (defaultly named origin)

                   PULL - Same as FETCH + MERGE

                   PUSH <origin> <local branch> - Pushes changes made to the
                                                  local branch to origin repo.




